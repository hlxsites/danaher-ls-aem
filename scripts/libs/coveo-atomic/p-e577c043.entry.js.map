{"version":3,"names":["AtomicResultLocalizedText","this","field","render","bindings","i18n","t","localeKey","parseFieldValues","parseFieldCount","ret","Object","keys","length","entries","forEach","fieldName","i18nParameter","fieldValueRaw","ResultTemplatesHelpers","getResultProperty","result","isNullOrUndefined","fieldCount","count","_a","__decorate","InitializeBindings","ResultContext","MapProp"],"sources":["src/components/search/result-template-components/atomic-result-localized-text/atomic-result-localized-text.ts"],"sourcesContent":["import {isNullOrUndefined} from '@coveo/bueno';\nimport {Result, ResultTemplatesHelpers} from '@coveo/headless';\nimport {Component, Prop, State} from '@stencil/core';\nimport {\n  InitializableComponent,\n  InitializeBindings,\n} from '../../../../utils/initialization-utils';\nimport {MapProp} from '../../../../utils/props-utils';\nimport {Bindings} from '../../atomic-search-interface/atomic-search-interface';\nimport {ResultContext} from '../result-template-decorators';\n\n/**\n * The `atomic-result-localized-text` component renders a target i18n localized string using the values of a target field.\n *\n * Given this i18n configuration:\n * ```\n * searchInterface.i18n.addResourceBundle('en', 'translation', {\n *    classic_book_advert: 'Classic book from {{name}}',\n * });\n * ```\n *\n * The component could be configured in such a way to replace `{{name}}` with the `author` field value from the result item:\n * ```\n * <atomic-result-localized-text locale-key=\"classic_book_advert\" field-author=\"name\"></atomic-result-localized-text>\n * ```\n *\n * @MapProp name: field;attr: field;docs: The field from which to extract the target string and the variable used to map it to the target i18n parameter. For example, the following configuration extracts the value of `author` from a result, and assign it to the i18n parameter `name`: `field-author=\"name\"`;type: Record<string, string> ;default: {}\n */\n@Component({\n  tag: 'atomic-result-localized-text',\n})\nexport class AtomicResultLocalizedText implements InitializableComponent {\n  @InitializeBindings() public bindings!: Bindings;\n  @State() public error!: Error;\n\n  @ResultContext() private result!: Result;\n  /**\n   * The i18n translation key.\n   */\n  @Prop() localeKey!: string;\n  /**\n   * The field value to dynamically evaluate.\n   */\n  @MapProp() field: Record<string, string> = {};\n  /**\n   * The numerical field value used to determine whether to use the singular or plural value of a translation.\n   * */\n  @Prop() fieldCount?: string;\n\n  render() {\n    return this.bindings.i18n.t(this.localeKey, {\n      ...this.parseFieldValues(),\n      ...this.parseFieldCount(),\n    });\n  }\n\n  private parseFieldValues() {\n    const ret: Record<string, unknown> = {};\n    if (Object.keys(this.field).length === 0) {\n      return ret;\n    }\n    Object.entries(this.field).forEach(([fieldName, i18nParameter]) => {\n      const fieldValueRaw = ResultTemplatesHelpers.getResultProperty(\n        this.result,\n        fieldName\n      );\n      if (!isNullOrUndefined(fieldValueRaw)) {\n        ret[i18nParameter] = fieldValueRaw;\n      }\n    });\n\n    return ret;\n  }\n\n  private parseFieldCount() {\n    if (!this.fieldCount) {\n      return {};\n    }\n    return {\n      count:\n        (ResultTemplatesHelpers.getResultProperty(\n          this.result,\n          this.fieldCount!\n        ) as number) ?? 1,\n    };\n  }\n}\n"],"mappings":"ipBA+BaA,EAAyB,M,yBAYzBC,KAAAC,MAAgC,G,wEAM3C,MAAAC,GACE,OAAOF,KAAKG,SAASC,KAAKC,EAAEL,KAAKM,UAAW,IACvCN,KAAKO,sBACLP,KAAKQ,mB,CAIJ,gBAAAD,GACN,MAAME,EAA+B,GACrC,GAAIC,OAAOC,KAAKX,KAAKC,OAAOW,SAAW,EAAG,CACxC,OAAOH,C,CAETC,OAAOG,QAAQb,KAAKC,OAAOa,SAAQ,EAAEC,EAAWC,MAC9C,MAAMC,EAAgBC,EAAuBC,kBAC3CnB,KAAKoB,OACLL,GAEF,IAAKM,EAAkBJ,GAAgB,CACrCR,EAAIO,GAAiBC,C,KAIzB,OAAOR,C,CAGD,eAAAD,G,MACN,IAAKR,KAAKsB,WAAY,CACpB,MAAO,E,CAET,MAAO,CACLC,OACEC,EAACN,EAAuBC,kBACtBnB,KAAKoB,OACLpB,KAAKsB,eACK,MAAAE,SAAA,EAAAA,EAAI,E,GAnDOC,EAAA,CAA5BC,K,+BAGwBD,EAAA,CAAxBE,K,6BAQUF,EAAA,CAAVG,K"}